# 1월 16일 목요일

- Ai와 법 강의
    
    ## AI와 법
    
    ### 목차
    
    1. AI 관련 저작권 이슈
    2. 할루시네이션(Hallucination)과 딥페이크
    3. AI와 개인정보
    
    ### 동향 정리
    
    EU AI act - 위험 기반 규제(Risk-based Approach)
    
    AI는 미국과 중국이 주도하고 있다 : EU에는 시장 판매자가 아닌 사용자의 입장이라서 규제에 더 관심을 가져서 제일 먼저 규제하는 법이 먼저 나오게 되었다.
    
    저작권이 무엇인가?? >>>> 권리의 다발이다
    
    ### 1. AI 관련 저작권 이슈
    
    크게 두 가지의 저작권 이슈가 있다.
    
    1. 학습을 할 데이터 세트에 대한 저작권(학습 분과)
    2. 학습한 데이터를 통한 산출물이 학습 데이터 세트와의 유사도(산출 분과)
    
    보통 저작권 관련 이슈는 뉴스 쪽을 AI가 사용해서 학습하는 것에 관한 것이 많다. 뉴욕타임즈 기사 무단 사용이 문제가 된 사건이다. 
    
    구체적인 침해 증거를 확보해야지 승소할 수 있는데, 
    
    1. AI 모델의 출력물 중 자신의 저작물과 실질적으로 유사한 부분을 찾아서 제시해야 한다.
    2. AI 회사가 자신의 저작물에 접근했다는 증거를 수집해야 한다. 예를 들어 공개적으로 접근 가능한 웹사이트에서 저작물이 스크랩 되었다는 증거 등이 필요함.
    
    ### 2. 할루시네이션과 딥페이크
    
    워터마크를 사용하는 등 AI를 통해서 산출된 결과물은 AI가 만들었다는 사실을 표시하기.
    
    ### 3. AI와 개인정보
    
    비정형 데이터에 녹아있는 개인정보를 AI가 학습하는 과정을 주의해야 한다.
    

# Start Camp

## 1일차 자료 이어서

### 1. CLI(Command Line Interface)

명령어를 통해 사용자와 컴퓨터가 상호 작용하는 방식(상호작용 : 컴퓨터를 동작할 수 있게 사용하는 방식)

### 2. GUI(Graphic User Interface)

그래픽을 통해 사용자와 컴퓨터가 상호 작용하는 방식

그렇다면 CLI를 사용하는 이유는 무엇일까?

1. 효율성 : 메모리와 cpu 사용량이 적다 → 제일 중요한 이유
2. 정밀한 제어 : 프로그램이나 시스템 세부 설정을 보다 정밀하게 제어
3. 표준성 : CLI 명령어는 대부분의 Unix 운영체제 기반 시스템에서 동일하게 작동하여 여러 환경 사용 가능

-vs code studio에 대해서 이야기 해보고 넘어가자

vs code studio는 단순히 언어(코드) 에디터 - 오작동도 많고, 에러도 많다. 강력한 익스텐션을 가지고 있는 언어 에디터이다. 익스텐션 + 커뮤니티 + 아무튼 편함

그럼 CLI를 VS code에서 실습해보자!!

1. **.** : 현재 디렉토리
2. **..** : 현재의 상위 디렉토리 - 현재 위치를 배시창에서 볼 수는 있지만 그 내부에 뭐가 있는 지에 대해서 확인할 수 는 없음.
3. **touch** : 파일 생성(모든 파일 생성 가능)
4. **mkdir(make directory)** : 새 디렉토리 생성
5. **ls(list**) : 현재 작업중인 디렉토리 내부의 폴더/파일 목록을 출력 - ls . 을 하게 되면 지금 파일 전부, ls .. 상위 디렉토리 모든 폴더 <<습관적으로 ls를 입력해서 뭐가 있는지를 확인하기>>
6. **clear or Ctrl + L** : bash 창 깨끗하게 치움
7. **cd** : 현재 작업중인 디렉토리를 변경(위치 이동) [cd new_dir/ , cd ..], 현재에서 찾아 들어감
8. **start** : 폴더/파일을 열기(start README.md, start a.txt)
9. **rm** : 파일 삭제(rm a.txt) - 그냥 사라짐, 디렉토리는 추가로 “-r”이 필요함 - (rm -r new_dir/) 

CLI에서 가장 중요한 것은 내가 어디 있는지(경로) 알아야 한다.

GUI에서 파일을 삭제하던 것을 키보드로 하는 것 뿐이다. - 필요할 때 필요한 명령어만 찾으면 된다.

---

### 절대경로

- Root 디렉토리(시작점)부터 목적 지점까지 거치는 모든 경로를 전부 작성한 것(C:/Users/ssafy/Desktop) 같은 윈도우 바탕화면 절대 경로(컴퓨터를 중심으로)

### 상대경로

- 현재 작업하고 있는 디렉토리를 기준으로 계산된 상대적 위치를 작성한 것 (만약 현재 작업하고 있는 디렉토리가 C:/Users일 때 바탕 화면으로의 상대 경로는 ssafy/Desktop이다.(나를 중심으로)

서버를 만들어서 배포할 때 서비스를 제공하는 입장에서 보면 내가 만든 서버를 보호하는 역할도 해야함. 그래서 서버의 Root 디렉토리는 제공하면 안됨!! 그래서 상대 경로를 사용하는 이유!!

---

---

## Git

- 분산 버전 관리 시스템(Distributed Version Control System)

### 버전관리

- 변화를 기록하고 추적하는 것
    - 구글 독스를 예시로 봐보자
        1. 안녕하세요 작성 후 버전1 저장
        2. 반갑습니다 추가 후 버전 2 저장
        3. 잘 부탁해요 추가 후 버전 3 저장
    - 각 버전은 이전 버전으로부터의 변경 사항을 기록하고 있음(누가, 언제, 어떻게 수정을 했는가)
    - 최초의 상태 + 변경 점들을 저장함으로서 모든 내용을 중복으로 저장하는 것이 아닌, 최종 파일 + 각각 버전들의 변경 사항(추가 사항)을 기록함, 이력 추적도 매우 간단함

### 분산

- 버전을 여러 개의 복제된 저장소에 저장 및 관리
    - 이전에는 **중앙 집중식**으로 버전은 중상서버에 저장되고 중앙서버에서 파일을 가져와 다시 중앙에 업로드하는 방식이었음, 최종 모습을 가지고 와서 사용 후 업로드
    - 제일 큰 이점은 중앙 서버의 장애나 손실에 대비하여 백업과 복구가 용이(이전에 어떠한 모습이었는지 알 수가 없음)
    - 여러가지 장점들
        1. 개발자들간의 작업 충돌을 줄이고 동시에 다양한 작업 가능, 개발 생산성 향상
        2. 중앙서버의 장애나 손시에 대비하여 백업과 복구가 용이
        3. 인터넷에 연결되지 않은 환경에서도 작업을 계속할 수 있음(변경 이력과 코드를 로컬에 저장하고 나중에 서버와 동기화)

### Git의 역할

- 코드의 버전(히스토리)를 관리
- 개발되어 온 과정 파악
- 이전 버전과의 변경 사항 비교
- 이따 undoing과 밀접한 연관을 가지고 있음

### **코드의 변경 이력을 기록하고 협업을 원할하게 하는 분산 버전 관리 시스템인 Git을 사용하게 됨!**

---

---

## Git의 영역

- Git은 3가지 영역이 있다.(꽤 난해한 내용이다!, 이해하기 어려움)
    - Working Directory(WD)
        - 실제 작업 중인 파일들이 위치하는 영역, 최종버전
    - Staging Area
        - Working Directory에서 변경된 파일 중, 다음 버전에 포함시킬 파일들을 선택적으로 추가하거나 제외할 수 있는 중간 준비 영역
    - Repository
        - 버전 이력(history)과 파일들이 영구적으로 저장되는 영역
        - 모든 버전과 변경 이력이 기록됨.
        - 버전 == commit == 변경된 파일들을 저장하는 행위이며, 마치 사진을 찍듯이 기록한다 하여 ‘snapshot’ 이라고도 함

### Git의 동작

- pwd(print working directory) - 지금 내가 작업하고 있는 디렉토리를 출력해라
- tab을 사용하면 자동완성

Git 과 관련한 모든 명령어는 git으로 시작

- git init : 로컬 저장소 설정(초기화). git의 버전관리를 시작할 디렉토리에서 진행(Working directory로)
- git add : 변경사항이 있는 파일을 staging area에 추가
- git commit : staging atra에 있는 파일들을 저장소에 기록, 해당 시점의 버전을 생성하고 변경 이력을 남기는 것

### Git 사용하기

1. 로컬 저장소 초기화
    1. git의 관리를 받기 시작한 디렉토리 내에서는 (master)가 표시됨
2. sample.txt 파일 생성 후 로컬 저장소의 파일 상태 확인
3. sample.txt 파일을 staging area에 추가
4. 로컬 저장소의 파일 상태 확인
5. commit 생성하기[git config —global [user.email](http://user.email) “메일주소”]
    
                                    [git config —global [user.name](http://user.name) “유저네임”]
    
    commit 작성자 정보 설정, global로 설정 후 앞으로 재입력하지 않음 ; 나중에 필요하면 또 해서 덮어씌우기
    
6. git 사용자 정보 등록
7. commit 생성하기 재시도 [git commit -m “first commit”]
8. commit 목록 확인  [git log]
9. 로컬 저장소의 파일 상태 확인  [git status]
10. sample.txt에 변경사항을 만든 뒤 저장 - 로컬 저장소의 파일 상태 확인  [git status]
11. 2번째 commit 생성 후 확인

- ls -a 를 하면 ./../.git/sample.txt가 보임, .git은 우리가 init 했을 때 생김 : 이 디렉토리에 여러가지가 저장됨, 여기가 repository, 여기에 우리가 사용하는 버전(commit), history, 설정이 담겨있음
- -a를 붙혔다는 것은, 이것이 숨김파일이라는 뜻이다. → 의미는 사용자가 이것을 건들 필요가 없다는 뜻이다.

### 그렇다면 Staging Area은 어디로 간 것일까??

- 우리가 “git add”도 사용
- 우리가 남긴 버전은 git_prac의 모습, working directory의 스냅샷

“”파일을 만들기만 하고서 (working directory)에 staging area에 올리면 안됨””

### 간단하게 생각하면

1. Working Directory에서 파일을 수정합니다.
2. 변경된 파일을 **`git add`** 명령어로 Staging Area에 추가합니다. (git status를 사용해서 확인)
3. Staging Area의 변경사항을 **`git commit`** 명령어로 Git Directory에 영구적으로 저장합니다

```python
git commit -m "버전의 이름 or 설명"
```

## 항상 현재 상태를 잘 확인하자!!

```python
git status
```

- working directory에서 관리하고 있어도 staging area에 올린 적이 없는 파일이라면 git에서 관리되지 않고 있는 것이다.

![image.png](image.png)

### 참고 내용들

- 로컬 - 현재 사용자가 접속한 기기 또는 시스템
- git status를 자주 활용하자, 내가 지금 사용하는 파일들이 어떻게 되어있고, snapshot으로 찍어도 되는 것인지
- git init은 로컬 저장소 내에 또 로컬 저장소를 만들면 안된다(루트 디렉토리에서 하면 안된다!!)
- algorism/list / string 이면 제일 높은 곳을 디렉토리로 init 해서 관리하고, 아래는 파일로 관리
- 커밋 메시지를 바꾸고 싶을 때는 —amend, insert mode 에서 수정 후 esc로 빠져나오고, 쉬프트 콜론으로 Vim 모드에 들어가서, [q - 빔 모드 종료, q! - 빔 모드 강제종료, wq - 저장 후 종료, wq! - 저장 후 강제종료]  , 수정하면 hash 값이 바뀐다{Vim모드}
- git commit —amend : 빠진 파일 넣었음, 오타 고침 같은 것은 유효한 commit 버전이 아니다. 즉, 불필요한 commit 버전을 수정할 수 있도록 해야 버전 관리를 잘 할 수 있음
- VIM 환경을 열기 위해서는 VI로 열 수 있음

여기까지가 1일차 pdf 내용

---

---

## Start Camp 2일차 내용

### Remote Repository(원격 저장소 서비스)

- repository의 기능은 그대로이며, local과 반대되는 개념으로 원격 저장소이다.
- gitlab, github, bitbucket 등이 있다.
    - gitlab : Git은 사용하지만 데이터베이스 서버를 직접 구축해서 사용하는 방법(보안성), jira, 무중단 배포, 자동 배포, 팀 단위 코드 공
    - github : 마이크로소프트의 제품으로, 마이크로소프트에서 다 사용 가능
    - bitbucket : 서버 직접 구축, 오픈 소스나 코드 공유를 목적으로 함

### Git remote

```python
git remote add origin(이름) remote_repo_url(주소)
```

- 위 코드를 통해서 로컬 repo와 github repo 연결 (Ctrl + v 가 잘 안되면 Shift + Insert로 하자)

```python
git push origin master
```

```python
git push -u origin master
```

- 위 코드를 통해서 연결된 github repo에 commit 목록을 push(업로드)
- -u를 사용해서 하면 다음에 또 push 할 때 git push 만 해도 가능하다. (로컬 master 브랜치가 원격의 master 브랜치를 추적하도록 설정)

```python
git pull origin master
```

- 기존의 어플을 업데이트하는 느낌, 작업하던 것을 팀원이 push 해주면 pull 해오기

```python
git clone (remote repository의 url)
```

- 새로운 어플을 다운로드 받는 느낌, 내 로컬에 없는 것을 받아옴

---

### Gitignore

- Git에서 특정 파일이나 디렉토리를 추적하지 않도록 설정하는 데 사용되는 텍스트 파일
- 일단 staging area에 올리고 내리는 것도 방법이지만, 비효율적이다.
- 공유하지 않아야 하는 파일이 있을 수도 있기 때문
- gitignore.io에 들어가서 필요한 운영체제, 개발 환경 등등을 통해서 파일을 만들 수 있음
    1. touch .gitignore을 통해서 파일 만들기
    2. 여러 파일들을 확장자명을 포함해서 내부에다가 적기
- 한 번 깃이 관리하기 시작한 경우는 gitignore에 추가 불가능, 처음에 다 해야함

- commit이 존재하면 restore, commit이 존재하지 않으면 rm. 즉 rm은 staging area 에서 working directory로 내리는 것.