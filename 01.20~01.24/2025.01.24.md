# Data Structure

## Data Structure

### 데이터 구조

- 데이터 구조 == 자료 구조 : 여러 데이터를 효과적으로 사용, 관리하기 위한 구조

### 데이터 구조 활용

- 문자열, 리스트, 딕셔너리 등 각 데이터 구조의 메서드를 호출하여 다양한 기능을 활용하기

### 메서드

- 어떠한 객체에 속한 함수
- 객체의 상태를 조작하거나 동작을 수행

### 메서드 특징

- 메서드는 클래스 내부에 정의되는 함수
- 클래스는 파이썬에서 ‘타입을 표현하는 방법’이며 은연중에 사용해왔음
- 예를 들어서 help 함수를 통해 str을 호출해보면 class 였다는 것을 확인 가능
- **지금은 메서드는 어딘가(클래스)에 속해 있는 함수이며, 각 데이터 타입별로 다양한 기능을 가진 메서드가 존재**
- str, list, dict 처럼 타입을 관리하는 친구들은 내장 함수이면서 class 이다.
- append 는 list 클래스만 사용 가능하다. list의 method

### 메서드 호출 방법

- 데이터 타입 객체.메서드(), 괄호도 필요

```python
'hello'.capitalize()
```

## 시퀀스 데이터 구조

### 문자열

### 문자열 조회/탐색 및 검증 메서드

| 메서드 | 설명 |
| --- | --- |
| s.find(x) | x의 첫번째 위치를 반환, 없으면 -1 반환 |
| s.index(x) | x의 첫번째 위치를 반환, 없으면 오류 발생 |
| s.isupper() | 문자열 내의 모든 문자가 대문자인지 확인 |
| s.islower() | 문자열 내의 모든 문자가 소문자인지 확인 |
| s.isalpha() | 문자열 내의 모든 문자가 알파벳인지 확인(유니코드상 letter, 한국어도 포함) |
- is로 시작하는 method의 반환값은 True or False, Boolean 이다.

### 문자열 조작 메서드(새 문자열 반환)

| 메서드 | 설명 |
| --- | --- |
| s.replace(old, new[, count]) | 바꿀 대상 글자를 새로운 글자로 바꿔서 반환, count는 바꿀 개수 |
| s.strip([chars]) | 공백이나 특정 문자를 제거 |
| s.split(sep = None, maxsplit =-1) | sep를 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트 반환 |
| ‘separator’.join(iterable) | 구분자로 iterable의 문자열을 연결한 문자열을 반환 |
| s.capitalize() | 가장 첫 번째 글자 대문자로 변경 |
| s.title() | 문자열 내 띄어쓰기 기준으로 각 단어의 첫 글자는 대문자로, 나머지는 소문자로 |
| s.upper() | 모두 대문자로 |
| s.lower() | 모두 소문자로 |
| s.swapcase() | 대문자 소문자 서로 변경 |
- s.replace(old, new[, count])
    - []는 선택적 인자로, 파이썬 문법이 아닌 기술적인 인자
- 불변이기 때문에 새로운 값을 반환 해주고 기존 것은 안바뀜
- .split(sep=None, maxsplit=1)
    - 기본은 공백 기준으로 나뉨
    - 리스트로 나옴
- ‘separator’.join(iterable)
    - 특이하게 앞에 구분자로 사용할 separator이 들어옴
    - 뒤에 반복 가능한 객체가 들어옴
    - 문자열 리스트에 정수가 있으면 에러뜸

### 리스트

### 리스트 값 추가 및 삭제 메서드

| 메서드 | 설명 |
| --- | --- |
| L.append(x) | 리스트 마지막에 항목 x를 추가, 이 함수에는 return이 없다. |
| L.extend(m) | Iterable m의 모든 항목들을 리스트 끝에 추가( +=과 같은 기능) |
| L.insert(i, x) | 리스트 인덱스 i에 항목 x를 삽입 |
| L.remove(x) | 리스트 가장 왼쪽에 있는 항목 x를 제거, 없으면 ValueError |
| L.pop() | 리스트 가장 오른쪽에 있는 항목(마지막)을 반환 후 제거 |
| L.pop(i) | 리스트 인덱스 i에 있는 항목을 반환 후 제거 |
| L.clear() | 리스트의 모든 항목 삭제 |
- 리스트는 가변이므로 원본이 바뀐다!
- extend와 append의 차이점 ([4, 5, 6])추가시
    - extend는 iterable한 데이터를 뒤에 추가해줌 (1, 2, 3, 4, 5, 6), 반복 가능 객체가 아니면 추가 불가능
    - append는 그냥 데이터를 추가(1, 2, 3, [4, 5, 6])
- 파이썬 공식 홈페이지에서 자주 찾아보자.
- L.pop(i)
    - 리스트에서 지정한 인덱스의 항목을 제거하고, 그 값을 반환, i를 작성하지 않으면 마지막 항목을 제거

### 리스트 탐색 및 정렬 메서드

| 문법 | 설명 |
| --- | --- |
| L.index(x) | 리스트에서 첫 번째로 일치하는 항목 x의 인덱스를 반환 |
| L.count(x) | 리스트에서 항목 x의 개수를 반환 |
| L.reverse() | 리스트의 순서를 역순으로 변경(정렬x) |
| L.sort() | 리스트를 정렬(매개변수를 이용가능), reverse = True 사용시 내림차순 정렬 가능 |
- 보통 원본 리스트를 바꾸는 메서드들은 return, 즉 반환값이 없음
- 공식문서 data structure에서 보자
- https://docs.python.org/3.9/tutorial/datastructures.html#data-structures

## 복사

- 복사와 재할당 잘 구분하기

### 가변/불변 객체 개념

- Mutable : 가변 객체 : 생성 후 내용을 변경할 수 있는 객체(리스트, 딕셔너리, 집합)
- Immutable : 불변 객체 : 생성 후 내용을 변경할 수 없는 객체(정수, 실수, 문자열, 듀플)

### 변수 할당의 의미

- 파이썬에서 변수 할당은 객체에 대한 참조를 생성하는 과정
    - 변수는 객체의 메모리 주소를 가리키는 Label 역할을 함
    - ‘=’ 연산자를 사용하여 변수에 값을 할당
    - 할당 시 새로운 객체가 생성되거나 기존 객체에 대한 참조가 생성됨
- 메모리 참조 방식
    - 변수는 객체의 메모리 주소를 저장
    - 여러 변수가 동일한 객체를 참조할 수 있음

### 가변객체

```python
a = [1, 2, 3, 4]
b = a
b[0] = 100

print(a) #[100, 2, 3, 4]
print(b) #[100, 2, 3, 4]
print(a is b) #True

```

- 위 내용은 단순히 할당을 했을 뿐 복사가 아니다.
- 같은 객체를 참조하므로 같은 값이다.

### 불변 객체

```python
a = 20
b = a
b = 10

print(a) # 20
print(b) # 10
print(a is b) # False
```

- 같은 과정을 해도 불변 객체의 경우에는 복사가 됨

### 가변/불변 메모리 관리 방식

- 가변 객체
    - 생성 후에도 그 내용을 수정할 수 있음
    - 객체의 내용이 변경되어도 같은 메모리 주소를 유지
- 불변 객체
    - 생성 후 그 값을 변경할 수 없음
    - 새로운 값을 할당하면 새로운 객체가 생성되고, 변수는 새 객체를 참조하게 됨

### 이러한 동작 방식 이유

1. 성능 최적화
    - 불변 객체는 변경이 불가능하므로, 여러 변수가 같은 객체를 안전하게 공유할 수 있음.
    - 가변 객체는 내용 수정이 빈번한 경우 새 객체를 생성하지 않고 직접 수정하여 성능 향상
2. 메모리 효율성
    - 불변 객체는 동일한 값을 가진 여러 객체가 메모리를 공유할 수 있어 효율적
    - 가변 객체는 크기가 큰 데이터를 효율적으로 수정할 수 있음

### 얕은 복사

- 객체의 최상위 요소만 새로운 메모리에 복사
- 내부에 중첩된 객체가 있다면 그 객체의 참조만 복사
- 얕은 복사 구현 방법
    1. 리스트 슬라이싱[,]
    2. copy() 메서드
    3. list() 함수

### 얕은 복사의 한계

- 2차원 리스트와 같이 변경 가능한 객체 안에 변경 가능한 객체가 있는 경우
- 같이 바뀌어 버림
- [1,2, [3,4,5]] → [3,4,5] 는 같은 곳을 바라봄

### 깊은 복사

- 객체의 모든 수준의 요소를 새로운 메모리에 복사
- 중첩된 객체까지 모두 새로운 메모리 주소를 가짐

```python
import copy
new_project = copy.deepcopy(original_object)
```

### 복잡한 중첩 예시

```python
print('\n복잡한 중첩 객체 깊은 복사')
original = {
    'a': [1, 2, 3],
    'b': {
        'c': 4,
        'd': [5, 6],
    },
}
copied = copy.deepcopy(original)

copied['a'][1] = 100
copied['b']['d'][0] = 500

print(f'원본: {original}')  #
print(f'복사본: {copied}')  #
print(
    f'original["b"]와 copied["b"]가 같은 객체인가? {original["b"] is copied["b"]}'
)  #
'''
복잡한 중첩 객체 깊은 복사
원본: {'a': [1, 2, 3], 'b': {'c': 4, 'd': [5, 6]}}
복사본: {'a': [1, 100, 3], 'b': {'c': 4, 'd': [500, 6]}}
original["b"]와 copied["b"]가 같은 객체인가? False
'''
```

## 참고

### 메서드 체이닝

- 여러 메서드를 연속해서 호출하는 방식
- 메서드 체이닝의 예시
    1. text.swapcase() : 대소문자 반전 + 문자열 반환
    2. text.swapcase().replace(’l’, ‘z’) : 소문자 ‘l’, ‘z’로 교체
- 앞 메서드의 결과가 문자열이라서 가능했음!!
- 리스트 조작에서 메서드 체이닝을 사용할 때는 각 메서드가 적절한 값을 반환하는지 확인하고, 필요한 경우 새로운 리스트 객체를 반환하는 함수를 사용하는 것이 좋음
- None을 반환하는 메서드는 체이닝 불가능(append(), sort())

### 문자 유형 판별 메서드